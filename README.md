# [The Rust Programming Language](https://doc.rust-lang.org/book/)

## 4. 理解所有权(Ownership)

所有权在 Rust 中是最特别的特性, 也深刻地影响其他语言. 这个特性使得 Rust 在不需要垃圾回收机制的情况下能够更加安全地处理内存, 因此了解所有权的工作机制很重要. 本章会探讨所有权和其他相关的特性: borrowing, slices 以及 Rust 如何在内存中处理数据.

### 4.1 什么是所有权

所有权是 Rust 程序管理内存的一系列规则. 所有程序在执行时都需要对计算机的内存进行控制. 有些编程语言中存在垃圾回收机制, 当程序运行时会不断寻找未被使用的内存, 而在某些其它编程语言中, 开发者必须自己去操作分配和释放内存. Rust 使用的是第三种方式: 内存通过系统的所有权以及编译器的一系列规则进行控制. 如果任何规则被打破, 程序就不会被成功编译. 可以放心的是, 所有权的特性不会拖慢程序运行的速度.

因为所有权对许多开发者来说是一个全新的概念, 所以需要花时间进行了解. 好消息是, 当我们对 Rust 的使用经验更丰富, 对所有权的规则越熟悉之后, 就能够更容易地写出安全有效的代码.

当我们理解了所有权的概念之后, 就会对 Rust 中的许多特性有更深刻的理解, 也正是这些特性使得 Rust 在编程语言中变得特别. 本章我们会通过一些示例来学习所有权的概念, 这些示例都围绕一个很常见的数据结构: `string` 展开. 


---

**栈和堆:**

在一些编程语言中, 我们无需考虑堆栈的概念. 但是在像 Rust 这样的系统编程语言中, 值被存储在栈中还是堆中对语言的行为有比较大的影响, 同时也会左右开发者如何去编写代码. 本章中关于所有权的一部分阐释, 会与堆栈的概念有所关联, 因此我们要事先了解什么是堆和栈.

栈和堆都是内存的一部分, 当我们的代码在运行时, 会用到它们. 不过栈与堆的结构有所不同. 我们按顺序在栈中存储数据, 然后以相反的顺序取出这些数据. 这个行为被称作是: **后进先出** (_last in, first out_). 想象一叠盘子, 当我们要添加更多盘子时, 会将它们置于顶部, 取出时也是从顶部取出. 添加和取出的操作都必须在顶部完成. 添加数据的行为被称作是: **进栈** (_pushing onto the stack_), 取出数据的行为则是: **出栈** (_popping off the stack_). 所有存在栈中的数据都需要有一个已知, 固定的大小. 如果数据的大小在编译阶段是未知或者实时可变的, 就应该存储在堆中.

堆相比栈来说, 组织性更差. 当我们在堆中存储数据的时候, 需要请求特定大小的空间. 内存分配工具会在堆中找一个尽可能大的未被使用的空间, 将其标志为已使用, 并返回一个 **指针**(_pointer_), 表示该空间的具体位置. 这个过程叫做: **在堆中分配内存** (_allocating on the heap_), 有时候被简称为 **分配** (_allocating_). 存储数据到栈中的操作不是分配. 由于堆所对应的指针大小已知且固定, 指针本身是被存储在栈中的, 不过当我们需要实际的数据时, 就需要去访问指针. 想象我们在餐厅就餐, 进入餐厅时我们会事先说明就餐人数, 之后服务员会带大家去到合适的空桌中. 如果某个人迟到了, 他也可以通过桌号找到目标位置.

入栈比在堆上分配内存更快, 因为在入栈的操作中, 内存分配器不需要去搜索数据存储在哪里, 存储的位置始终是栈顶. 同时两者相比, 在堆中分配内存需要更多的工作, 因为分配器首先要找到一个足够大的空间来存储数据, 然后进行一些记录, 为下一次分配做准备.

从堆中获取数据比从栈中获取数据更慢, 因为首先要访问指针. 对于当下的处理器来说, 在内存中跳转频次越少, 处理速度就越快. 继续同样的类比, 想象餐厅服务员要处理多个餐桌的点单. 最有效的方式是在一个餐桌中获取完成所有点单之后再去到下一个餐桌. 如果从餐桌 A 获取一部分点单之后, 又去到餐桌 B 获取一部分点单, 然后返回 A 继续获取点单, 接着去 B 餐桌, 这样的过程就会很慢很繁琐. 因此同样地, 当处理器需要处理的数据与其他数据位置比较近的时候, 处理器的工作就能更高效. 分配堆中的一大部分空间也会消耗比较多的时间.

当我们的代码调用一个函数时, 值被传入函数中(这个值也可能包括指向堆中数据的指针)并且函数中的本地变量被压入栈中. 当函数执行结束, 这些值又被移出栈. 

记录哪部分的代码在使用堆中的数据, 尽量减少在堆中存储重复的数据, 清除堆中未被使用的数据, 避免使用太多的空间, 这些都是所有权需要处理的问题. 一旦你理解了所有权的概念, 你就不需要考虑太多堆和栈了. 不过, 知道了所有权的最主要目的是处理堆数据, 能够帮助我们更好地理解所有权的工作机制.

---

### 所有权的规则

首先我们来看看所有权的规则. 记住这些规则, 在我们使用示例阐述所有权概念的时候, 这些规则会很有用:

- 在 Rust 中, 每一个值都存在一个对应的变量, 这个变量叫做 **所有者** (_owner_).
- 一个值在一个阶段只能存在一个所有者.
- 当所有者离开作用域之后, 该值也同时被丢弃.


### 变量的作用域

现在我们已经了解了 Rust 的基本语法, 在后续的代码示例中, 就不会再添加 `fn main() {` 这部分代码了, 因此需要注意在仿照示例时, 确保你的代码中添加了这部分代码. 这样做的原因是能够使得我们的示例代码更加简洁, 我们只需要关注应该关注的细节就可以, 不需要理会对于阐释没有帮助的部分.

在第一个所有权例子中, 我们关注一些变量的`作用域`. 作用域指的是, 一个项(item)在程序中有效的范围. 查看以下示例:

```rust
let s = "hello";
```

变量`s`绑定到了一个字符串字面量值, 这个字符串值被硬编码进了我们的程序代码中. 这个变量从开始声明直到当前 _作用域_ 结束, 都是有效的. 以下代码示例中的注释说明了变量 `s` 在程序的哪个位置是有效的.

```rust
fn main() {
    {                      // s 还未被声明, 因此在这里不合法 
        let s = "hello";   // s 在这里开始合法

        // 可以在这里开始对 s 进行操作
    }                      // 作用域结束, s 不再合法
}
```

换句话说, 这里有两个重要的时间点:

- 当 `s` 进入作用域之后, 它就合法了.
- 这一过程持续直到当前作用域结束.

在这种情况下, 作用域和变量的关联关系和在其他编程语言上无异. 现在我们开始通过 `String` 类型的示例来进行详细的阐释.

### `String` 类型

为了更好地解释所有权的概念, 我们需要一种比第三章中讲到的更复杂的数据类型. 之前我们提到的数据类型都是已知大小的, 可以被存储在栈中, 当作用域结束之后又被弹出栈.
